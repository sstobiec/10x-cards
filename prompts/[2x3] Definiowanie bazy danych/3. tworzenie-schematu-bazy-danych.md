Jesteś architektem baz danych, którego zadaniem jest stworzenie schematu bazy danych PostgreSQL na podstawie informacji dostarczonych z sesji planowania, dokumentu wymagań produktu (PRD) i stacku technologicznym. Twoim celem jest zaprojektowanie wydajnej i skalowalnej struktury bazy danych, która spełnia wymagania projektu.

1. <prd>
{{prd}} <- zamień na referencję do @prd.md
</prd>

Jest to dokument wymagań produktu, który określa cechy, funkcjonalności i wymagania projektu.

2. <session_notes>

<conversation_summary>
<decisions>
1.  **Zarządzanie użytkownikami**: System będzie opierał się wyłącznie na wbudowanej tabeli `auth.users` od Supabase. Nazwa użytkownika będzie przechowywana w polu `raw_user_meta_data` (JSONB).
2.  **Encje i Relacje**:
    *   `users` (z `auth.users`) ma relację jeden-do-wielu z `flashcard_sets`.
    *   `flashcard_sets` ma relację jeden-do-wielu z `flashcards`.
    *   Usunięcie użytkownika (`auth.users`) spowoduje kaskadowe usunięcie (`ON DELETE CASCADE`) wszystkich jego zestawów (`flashcard_sets`) i powiązanych z nimi fiszek.
3.  **Struktura Tabel**:
    *   `flashcard_sets`: Będzie zawierać `user_id` (klucz obcy do `auth.users.id`), `name` (`VARCHAR(100)`, `NOT NULL`) oraz `created_at` i `updated_at`. Para (`user_id`, `name`) musi być unikalna.
    *   `flashcards`: Będzie zawierać `set_id` (klucz obcy do `flashcard_sets.id`), `avers` (`VARCHAR(200)`), `rewers` (`VARCHAR(750)`), `source` (typu `flashcard_source ENUM`), kolumnę `flagged` do oznaczania słabej jakości oraz `created_at` i `updated_at`.
    *   `flashcard_sets_error_logs`: Nowa tabela do logowania błędów związanych z zestawami fiszek.
4.  **Śledzenie pochodzenia fiszek**: Kolumna `source` będzie typu `ENUM` (`'manual'`, `'ai-full'`, `'ai-edited'`). Edycja fiszki wygenerowanej przez AI zmieni jej status z `ai-full` na `ai-edited`.
5.  **Mechanizm informacji zwrotnej**: Do tabeli `flashcards` zostanie dodana kolumna `flagged` (prawdopodobnie `BOOLEAN` lub `INTEGER`) do oznaczania fiszek słabej jakości.
6.  **Bezpieczeństwo**: Polityki bezpieczeństwa na poziomie wiersza (RLS) zostaną włączone dla wszystkich tabel (`flashcard_sets`, `flashcards`) i wszystkich operacji (`SELECT`, `INSERT`, `UPDATE`, `DELETE`), aby zapewnić, że użytkownicy mają dostęp wyłącznie do swoich danych (`auth.uid() = user_id`).
7.  **Walidacja danych**: Walidacja długości tekstu dla pól `avers` i `rewers` będzie realizowana po stronie aplikacji.
8.  **Spaced Repetition**: Implementacja tabeli do śledzenia postępów w nauce (`user_flashcard_progress`) jest odłożona do momentu wyboru odpowiedniej biblioteki.
9.  **Konwencje**: Przyjęto konwencję nazewnictwa `snake_case` dla wszystkich obiektów bazy danych.
</decisions>

<matched_recommendations>
1.  **Integralność danych**: Zastosowano klauzulę `ON DELETE CASCADE` na kluczu obcym `user_id` w tabeli `flashcard_sets`, aby zapewnić spójność danych po usunięciu konta użytkownika.
2.  **Bezpieczeństwo**: Zdefiniowano kompleksowe polityki RLS dla wszystkich operacji (CRUD), aby w pełni izolować dane poszczególnych użytkowników na poziomie bazy danych.
3.  **Struktura i typowanie**: Zdefiniowano dedykowany typ `ENUM` dla pochodzenia fiszek, co poprawia integralność i czytelność danych.
4.  **Audyt Danych**: Dodano kolumny `created_at` i `updated_at` do kluczowych tabel, co jest standardową praktyką ułatwiającą zarządzanie i debugowanie.
5.  **Ograniczenia unikalności**: Wprowadzono ograniczenie `UNIQUE` dla pary (`user_id`, `name`) w `flashcard_sets`, aby poprawić użyteczność i zapobiec duplikatom.
6.  **Przechowywanie metadanych**: Wykorzystano pole `raw_user_meta_data` w tabeli `auth.users` jako efektywne rozwiązanie dla przechowywania nazwy użytkownika bez tworzenia dodatkowych tabel w ramach MVP.
</matched_recommendations>

<database_planning_summary>
Na podstawie analizy wymagań produktu (PRD) i dyskusji technicznej, zaplanowano schemat bazy danych PostgreSQL dla MVP aplikacji 10xCards, zintegrowany z Supabase.

**Główne wymagania dotyczące schematu bazy danych:**
Schemat musi obsługiwać uwierzytelnianie użytkowników, przechowywanie zestawów fiszek i samych fiszek, śledzenie pochodzenia fiszek (ręczne vs. AI) oraz umożliwiać użytkownikom oznaczanie fiszek o niskiej jakości. Schemat musi być zabezpieczony w taki sposób, aby użytkownicy mieli dostęp wyłącznie do swoich danych.

**Kluczowe encje i ich relacje:**
1.  **`users`**: Obsługiwane przez `auth.users` Supabase. Jest to encja nadrzędna dla zestawów fiszek.
2.  **`flashcard_sets`**: Przechowuje nazwane kolekcje fiszek. Każdy zestaw należy do jednego użytkownika (relacja wiele-do-jednego z `users`). Nazwa zestawu musi być unikalna dla danego użytkownika.
3.  **`flashcards`**: Reprezentuje pojedynczą fiszkę (awers/rewers). Każda fiszka należy do jednego zestawu (relacja wiele-do-jednego z `flashcard_sets`). Zawiera metadane takie jak źródło (`source`) i flaga jakości (`flagged`).
4.  **`flashcard_sets_error_logs`**: Dedykowana tabela do rejestrowania błędów, które mogą wystąpić podczas operacji na zestawach fiszek.

**Ważne kwestie dotyczące bezpieczeństwa i skalowalności:**
*   **Bezpieczeństwo**: Głównym filarem bezpieczeństwa jest RLS (Row-Level Security) włączone dla wszystkich tabel. Zasady te zapewnią ścisłą izolację danych, uniemożliwiając odczyt i modyfikację zasobów nienależących do zalogowanego użytkownika.
*   **Skalowalność**: Zdecydowano o odłożeniu implementacji tabeli postępów nauki, co zmniejsza początkową złożoność bazy danych. Podstawowe indeksy na kluczach obcych (`user_id`, `set_id`) zapewnią odpowiednią wydajność dla kluczowych zapytań w ramach MVP.

</database_planning_summary>

<unresolved_issues>
1.  **Struktura tabeli `flashcard_sets_error_logs`**: Nie zdefiniowano szczegółowej struktury tej tabeli. Konieczne jest określenie, jakie kolumny powinna zawierać (np. `id`, `user_id`, `set_id`, `error_message`, `payload`, `created_at`) oraz jakie konkretnie błędy będą w niej logowane (np. błędy generowania przez AI, błędy walidacji).
2.  **Definicja kolumny `flagged`**: Nie sprecyzowano typu danych ani domyślnej wartości dla kolumny `flagged` w tabeli `flashcards`. Należy zdecydować, czy ma to być `BOOLEAN` (domyślnie `false`) czy `INTEGER` (domyślnie `0`).
</unresolved_issues>
</conversation_summary>

</session_notes>

Są to notatki z sesji planowania schematu bazy danych. Mogą one zawierać ważne decyzje, rozważania i konkretne wymagania omówione podczas spotkania.

3. <tech_stack>
{{tech-stack}} <- zamień na referencje do tech-stack.md
</tech_stack>

Opisuje stack technologiczny, który zostanie wykorzystany w projekcie, co może wpłynąć na decyzje dotyczące projektu bazy danych.

Wykonaj następujące kroki, aby utworzyć schemat bazy danych:

1. Dokładnie przeanalizuj notatki z sesji, identyfikując kluczowe jednostki, atrybuty i relacje omawiane podczas sesji planowania.
2. Przejrzyj PRD, aby upewnić się, że wszystkie wymagane funkcje i funkcjonalności są obsługiwane przez schemat bazy danych.
3. Przeanalizuj stack technologiczny i upewnij się, że projekt bazy danych jest zoptymalizowany pod kątem wybranych technologii.

4. Stworzenie kompleksowego schematu bazy danych, który obejmuje
   a. Tabele z odpowiednimi nazwami kolumn i typami danych
   b. Klucze podstawowe i klucze obce
   c. Indeksy poprawiające wydajność zapytań
   d. Wszelkie niezbędne ograniczenia (np. unikalność, not null)

5. Zdefiniuj relacje między tabelami, określając kardynalność (jeden-do-jednego, jeden-do-wielu, wiele-do-wielu) i wszelkie tabele łączące wymagane dla relacji wiele-do-wielu.

6. Opracowanie zasad PostgreSQL dla zabezpieczeń na poziomie wiersza (RLS), jeśli dotyczy, w oparciu o wymagania określone w notatkach z sesji lub PRD.

7. Upewnij się, że schemat jest zgodny z najlepszymi praktykami projektowania baz danych, w tym normalizacji do odpowiedniego poziomu (zwykle 3NF, chyba że denormalizacja jest uzasadniona ze względu na wydajność).

Ostateczny wynik powinien mieć następującą strukturę:
```markdown
1. Lista tabel z ich kolumnami, typami danych i ograniczeniami
2. Relacje między tabelami
3. Indeksy
4. Zasady PostgreSQL (jeśli dotyczy)
5. Wszelkie dodatkowe uwagi lub wyjaśnienia dotyczące decyzji projektowych
```

W odpowiedzi należy podać tylko ostateczny schemat bazy danych w formacie markdown, który zapiszesz w pliku .ai/db-plan.md bez uwzględniania procesu myślowego lub kroków pośrednich. Upewnij się, że schemat jest kompleksowy, dobrze zorganizowany i gotowy do wykorzystania jako podstawa do tworzenia migracji baz danych.