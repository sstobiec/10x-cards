/**
 * DTO (Data Transfer Object) and Command Model Types
 *
 * This file contains all DTOs used for API requests/responses.
 * All types are derived from database models in database.types.ts
 * to ensure type safety and consistency.
 */

import { z } from 'zod';
import type { Tables, TablesInsert, Enums } from "./db/database.types";

// ============================================================================
// Database Entity Type Aliases (for convenience)
// ============================================================================

export type FlashcardSetEntity = Tables<"flashcard_sets">;
export type FlashcardEntity = Tables<"flashcards">;
export type ErrorLogEntity = Tables<"error_logs">;
export type FlashcardSource = Enums<"flashcard_source">;

// ============================================================================
// Common/Utility DTOs
// ============================================================================

/**
 * Pagination metadata included in list responses
 */
export interface PaginationMetaDTO {
  total: number;
  limit: number;
  offset: number;
}

/**
 * Generic paginated response wrapper
 */
export interface PaginatedResponseDTO<T> {
  data: T[];
  pagination: PaginationMetaDTO;
}

/**
 * Standard error response format
 */
export interface ErrorResponseDTO {
  error: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
}

// ============================================================================
// AI Flashcard Generation DTOs
// ============================================================================

/**
 * Request to generate flashcards from text using AI
 * POST /api/flashcards/generate
 */
export interface GenerateFlashcardsRequestDTO {
  /** Input text to generate flashcards from (max 10,000 characters) */
  text: string;
  /** AI model to use (optional, defaults to configured model) */
  model?: string;
}

/**
 * Single flashcard proposal generated by AI (not yet saved to database)
 */
export interface FlashcardProposalDTO {
  /** Front of the flashcard (question) */
  avers: string;
  /** Back of the flashcard (answer) */
  rewers: string;
}

/**
 * Response containing AI-generated flashcard proposals
 * POST /api/flashcards/generate
 */
export interface GenerateFlashcardsResponseDTO {
  /** Array of generated flashcard proposals */
  flashcard_proposals: FlashcardProposalDTO[];
  /** Time taken to generate flashcards (milliseconds) */
  generation_duration: number;
  /** AI model used for generation */
  model: string;
}

// ============================================================================
// Flashcard Set DTOs
// ============================================================================

/**
 * Flashcard set in list view (summary without flashcards)
 * GET /api/flashcard-sets
 */
export interface FlashcardSetListItemDTO
  extends Pick<FlashcardSetEntity, "id" | "name" | "model" | "generation_duration" | "created_at" | "updated_at"> {
  /** Number of flashcards in this set (computed field) */
  flashcard_count: number;
}

/**
 * Flashcard set detail view (includes all flashcards)
 * GET /api/flashcard-sets/:id
 */
export interface FlashcardSetDetailDTO extends Omit<FlashcardSetEntity, "user_id"> {
  /** All flashcards in this set */
  flashcards: FlashcardDTO[];
}

/**
 * Request to create a new flashcard set
 * POST /api/flashcard-sets
 */
export interface CreateFlashcardSetRequestDTO {
  /** Name of the flashcard set (max 100 characters, unique per user) */
  name: string;
  /** Model used to generate flashcards (use "manual" for manually created sets) */
  model: string;
  /** Time taken to generate (milliseconds, use 0 for manual sets) */
  generation_duration: number;
  /** Optional array of flashcards to create with the set */
  flashcards?: FlashcardCreateCommand[];
}

/**
 * Response after creating a flashcard set
 * POST /api/flashcard-sets
 */
export type CreateFlashcardSetResponseDTO = FlashcardSetListItemDTO;

/**
 * Request to update a flashcard set
 * PATCH /api/flashcard-sets/:id
 */
export interface UpdateFlashcardSetRequestDTO {
  /** Updated name for the flashcard set */
  name: string;
}

/**
 * Response after updating a flashcard set
 * PATCH /api/flashcard-sets/:id
 */
export type UpdateFlashcardSetResponseDTO = FlashcardSetListItemDTO;

// ============================================================================
// Flashcard DTOs
// ============================================================================

/**
 * Complete flashcard entity (used in responses)
 */
export type FlashcardDTO = FlashcardEntity;

/**
 * Request to create a new flashcard
 * POST /api/flashcard-sets/:setId/flashcards
 */
export type CreateFlashcardRequestDTO = Pick<TablesInsert<"flashcards">, "avers" | "rewers" | "source">;

/**
 * Response after creating a flashcard
 * POST /api/flashcard-sets/:setId/flashcards
 */
export type CreateFlashcardResponseDTO = FlashcardDTO;

/**
 * Request to update a flashcard
 * PATCH /api/flashcards/:id
 */
export interface UpdateFlashcardRequestDTO {
  /** Updated front of flashcard (optional) */
  avers?: string;
  /** Updated back of flashcard (optional) */
  rewers?: string;
}

/**
 * Response after updating a flashcard
 * PATCH /api/flashcards/:id
 */
export type UpdateFlashcardResponseDTO = FlashcardDTO;

/**
 * Request to toggle flashcard flag status
 * PATCH /api/flashcards/:id/flag
 */
export interface ToggleFlashcardFlagRequestDTO {
  /** New flagged status */
  flagged: boolean;
}

/**
 * Response after toggling flashcard flag
 * PATCH /api/flashcards/:id/flag
 */
export type ToggleFlashcardFlagResponseDTO = Pick<FlashcardEntity, "id" | "flagged" | "updated_at">;

// ============================================================================
// Error Log DTOs
// ============================================================================

/**
 * Request to create an error log entry
 * POST /api/error-logs
 */
export type CreateErrorLogRequestDTO = Pick<
  TablesInsert<"error_logs">,
  "model" | "error_type" | "error_message" | "input_payload"
>;

/**
 * Response after creating an error log entry
 * POST /api/error-logs
 */
export type CreateErrorLogResponseDTO = Omit<ErrorLogEntity, "input_payload">;

// ============================================================================
// Command Models (for complex create operations)
// ============================================================================

/**
 * Command to create a flashcard (used when creating flashcards within a set)
 */
export interface FlashcardCreateCommand {
  /** Front of the flashcard (question) */
  avers: string;
  /** Back of the flashcard (answer) */
  rewers: string;
  /** Source of the flashcard */
  source: FlashcardSource;
  /** Whether the flashcard is flagged as low quality */
  flagged: boolean;
}

/**
 * Command to create a flashcard set with nested flashcards
 */
export interface FlashcardSetCreateCommand {
  /** Name of the flashcard set */
  name: string;
  /** Model used to generate flashcards */
  model: string;
  /** Time taken to generate (milliseconds) */
  generation_duration: number;
  /** Flashcards to create with the set */
  flashcards: FlashcardCreateCommand[];
}

// ============================================================================
// Type Guards (for runtime type checking)
// ============================================================================

/**
 * Type guard to check if a value is a valid FlashcardSource
 */
export function isFlashcardSource(value: unknown): value is FlashcardSource {
  return typeof value === "string" && ["manual", "ai-full", "ai-edited"].includes(value);
}

/**
 * Type guard to check if an object has the required shape of CreateFlashcardRequestDTO
 */
export function isCreateFlashcardRequest(value: unknown): value is CreateFlashcardRequestDTO {
  if (typeof value !== "object" || value === null) return false;
  const obj = value as Record<string, unknown>;
  return typeof obj.avers === "string" && typeof obj.rewers === "string" && isFlashcardSource(obj.source);
}

/**
 * Type guard to check if an object has the required shape of UpdateFlashcardRequestDTO
 */
export function isUpdateFlashcardRequest(value: unknown): value is UpdateFlashcardRequestDTO {
  if (typeof value !== "object" || value === null) return false;
  const obj = value as Record<string, unknown>;
  return (
    (obj.avers === undefined || typeof obj.avers === "string") &&
    (obj.rewers === undefined || typeof obj.rewers === "string")
  );
}

// ============================================================================
// View Models (for UI state management)
// ============================================================================

/**
 * Represents the overall state of the generation view
 */
export type GenerationViewState =
  | "idle" // Initial state
  | "generating" // Flashcards are being generated
  | "reviewing" // User is reviewing and editing proposals
  | "saving" // Set is being saved
  | "success" // Set successfully saved
  | "error"; // An error occurred

/**
 * Represents a flashcard proposal in the UI state
 */
export interface FlashcardProposalViewModel {
  /** Unique client-side identifier (e.g. uuidv4) */
  id: string;
  /** Front of the flashcard (question) */
  avers: string;
  /** Back of the flashcard (answer) */
  rewers: string;
  /** Source of the flashcard */
  source: "ai-full" | "ai-edited";
  /** Whether the flashcard is flagged as low quality */
  isFlagged: boolean;
}

/**
 * Represents an API error to display in the UI
 */
export interface ApiError {
  title: string;
  message: string;
  details?: Record<string, unknown>;
}

// ============================================================================
// Zod Schemas for OpenRouter API Integration
// ============================================================================

/**
 * Zod schema for a single flashcard proposal
 */
export const FlashcardProposalSchema = z.object({
  avers: z.string().min(1).describe('Pytanie, które pojawi się na awersie fiszki.'),
  rewers: z.string().min(1).describe('Odpowiedź, która pojawi się na rewersie fiszki.'),
});

/**
 * Zod schema for flashcard generation response
 */
export const FlashcardGenerationSchema = z.object({
  flashcard_proposals: z
    .array(FlashcardProposalSchema)
    .min(1)
    .max(20)
    .describe('Lista wygenerowanych propozycji fiszek (od 1 do 20).'),
});

/**
 * Type inferred from FlashcardGenerationSchema
 */
export type FlashcardGeneration = z.infer<typeof FlashcardGenerationSchema>;
