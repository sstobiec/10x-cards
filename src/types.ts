/**
 * DTO (Data Transfer Object) and Command Model Types
 *
 * This file contains all DTOs used for API requests/responses.
 * All types are derived from database models in database.types.ts
 * to ensure type safety and consistency.
 */

import type { Tables, TablesInsert, Enums } from "./db/database.types";

// ============================================================================
// Database Entity Type Aliases (for convenience)
// ============================================================================

export type FlashcardSetEntity = Tables<"flashcard_sets">;
export type FlashcardEntity = Tables<"flashcards">;
export type ErrorLogEntity = Tables<"error_logs">;
export type FlashcardSource = Enums<"flashcard_source">;

// ============================================================================
// Common/Utility DTOs
// ============================================================================

/**
 * Pagination metadata included in list responses
 */
export interface PaginationMetaDTO {
  total: number;
  limit: number;
  offset: number;
}

/**
 * Generic paginated response wrapper
 */
export interface PaginatedResponseDTO<T> {
  data: T[];
  pagination: PaginationMetaDTO;
}

/**
 * Standard error response format
 */
export interface ErrorResponseDTO {
  error: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
}

// ============================================================================
// AI Flashcard Generation DTOs
// ============================================================================

/**
 * Request to generate flashcards from text using AI
 * POST /api/flashcards/generate
 */
export interface GenerateFlashcardsRequestDTO {
  /** Input text to generate flashcards from (max 10,000 characters) */
  text: string;
  /** AI model to use (optional, defaults to configured model) */
  model?: string;
}

/**
 * Single flashcard proposal generated by AI (not yet saved to database)
 */
export interface FlashcardProposalDTO {
  /** Front of the flashcard (question) */
  avers: string;
  /** Back of the flashcard (answer) */
  rewers: string;
}

/**
 * Response containing AI-generated flashcard proposals
 * POST /api/flashcards/generate
 */
export interface GenerateFlashcardsResponseDTO {
  /** Array of generated flashcard proposals */
  flashcard_proposals: FlashcardProposalDTO[];
  /** Time taken to generate flashcards (milliseconds) */
  generation_duration: number;
  /** AI model used for generation */
  model: string;
}

// ============================================================================
// Flashcard Set DTOs
// ============================================================================

/**
 * Flashcard set in list view (summary without flashcards)
 * GET /api/flashcard-sets
 */
export interface FlashcardSetListItemDTO
  extends Pick<FlashcardSetEntity, "id" | "name" | "model" | "generation_duration" | "created_at" | "updated_at"> {
  /** Number of flashcards in this set (computed field) */
  flashcard_count: number;
}

/**
 * Flashcard set detail view (includes all flashcards)
 * GET /api/flashcard-sets/:id
 */
export interface FlashcardSetDetailDTO extends Omit<FlashcardSetEntity, "user_id"> {
  /** All flashcards in this set */
  flashcards: FlashcardDTO[];
}

/**
 * Request to create a new flashcard set
 * POST /api/flashcard-sets
 */
export interface CreateFlashcardSetRequestDTO {
  /** Name of the flashcard set (max 100 characters, unique per user) */
  name: string;
  /** Model used to generate flashcards (use "manual" for manually created sets) */
  model: string;
  /** Time taken to generate (milliseconds, use 0 for manual sets) */
  generation_duration: number;
  /** Optional array of flashcards to create with the set */
  flashcards?: FlashcardCreateCommand[];
}

/**
 * Response after creating a flashcard set
 * POST /api/flashcard-sets
 */
export type CreateFlashcardSetResponseDTO = FlashcardSetListItemDTO;

/**
 * Request to update a flashcard set
 * PATCH /api/flashcard-sets/:id
 */
export interface UpdateFlashcardSetRequestDTO {
  /** Updated name for the flashcard set */
  name: string;
}

/**
 * Response after updating a flashcard set
 * PATCH /api/flashcard-sets/:id
 */
export type UpdateFlashcardSetResponseDTO = FlashcardSetListItemDTO;

// ============================================================================
// Flashcard DTOs
// ============================================================================

/**
 * Complete flashcard entity (used in responses)
 */
export type FlashcardDTO = FlashcardEntity;

/**
 * Request to create a new flashcard
 * POST /api/flashcard-sets/:setId/flashcards
 */
export type CreateFlashcardRequestDTO = Pick<TablesInsert<"flashcards">, "avers" | "rewers" | "source">;

/**
 * Response after creating a flashcard
 * POST /api/flashcard-sets/:setId/flashcards
 */
export type CreateFlashcardResponseDTO = FlashcardDTO;

/**
 * Request to update a flashcard
 * PATCH /api/flashcards/:id
 */
export interface UpdateFlashcardRequestDTO {
  /** Updated front of flashcard (optional) */
  avers?: string;
  /** Updated back of flashcard (optional) */
  rewers?: string;
}

/**
 * Response after updating a flashcard
 * PATCH /api/flashcards/:id
 */
export type UpdateFlashcardResponseDTO = FlashcardDTO;

/**
 * Request to toggle flashcard flag status
 * PATCH /api/flashcards/:id/flag
 */
export interface ToggleFlashcardFlagRequestDTO {
  /** New flagged status */
  flagged: boolean;
}

/**
 * Response after toggling flashcard flag
 * PATCH /api/flashcards/:id/flag
 */
export type ToggleFlashcardFlagResponseDTO = Pick<FlashcardEntity, "id" | "flagged" | "updated_at">;

// ============================================================================
// Error Log DTOs
// ============================================================================

/**
 * Request to create an error log entry
 * POST /api/error-logs
 */
export type CreateErrorLogRequestDTO = Pick<
  TablesInsert<"error_logs">,
  "model" | "error_type" | "error_message" | "input_payload"
>;

/**
 * Response after creating an error log entry
 * POST /api/error-logs
 */
export type CreateErrorLogResponseDTO = Omit<ErrorLogEntity, "input_payload">;

// ============================================================================
// Command Models (for complex create operations)
// ============================================================================

/**
 * Command to create a flashcard (used when creating flashcards within a set)
 */
export interface FlashcardCreateCommand {
  /** Front of the flashcard (question) */
  avers: string;
  /** Back of the flashcard (answer) */
  rewers: string;
  /** Source of the flashcard */
  source: FlashcardSource;
}

/**
 * Command to create a flashcard set with nested flashcards
 */
export interface FlashcardSetCreateCommand {
  /** Name of the flashcard set */
  name: string;
  /** Model used to generate flashcards */
  model: string;
  /** Time taken to generate (milliseconds) */
  generation_duration: number;
  /** Flashcards to create with the set */
  flashcards: FlashcardCreateCommand[];
}

// ============================================================================
// Type Guards (for runtime type checking)
// ============================================================================

/**
 * Type guard to check if a value is a valid FlashcardSource
 */
export function isFlashcardSource(value: unknown): value is FlashcardSource {
  return typeof value === "string" && ["manual", "ai-full", "ai-edited"].includes(value);
}

/**
 * Type guard to check if an object has the required shape of CreateFlashcardRequestDTO
 */
export function isCreateFlashcardRequest(value: unknown): value is CreateFlashcardRequestDTO {
  if (typeof value !== "object" || value === null) return false;
  const obj = value as Record<string, unknown>;
  return typeof obj.avers === "string" && typeof obj.rewers === "string" && isFlashcardSource(obj.source);
}

/**
 * Type guard to check if an object has the required shape of UpdateFlashcardRequestDTO
 */
export function isUpdateFlashcardRequest(value: unknown): value is UpdateFlashcardRequestDTO {
  if (typeof value !== "object" || value === null) return false;
  const obj = value as Record<string, unknown>;
  return (
    (obj.avers === undefined || typeof obj.avers === "string") &&
    (obj.rewers === undefined || typeof obj.rewers === "string")
  );
}
