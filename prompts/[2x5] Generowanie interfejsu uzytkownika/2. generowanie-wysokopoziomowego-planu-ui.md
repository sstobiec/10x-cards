Jesteś wykwalifikowanym architektem frontend, którego zadaniem jest stworzenie kompleksowej architektury interfejsu użytkownika w oparciu o dokument wymagań produktu (PRD), plan API i notatki z sesji planowania. Twoim celem jest zaprojektowanie struktury interfejsu użytkownika, która skutecznie spełnia wymagania produktu, jest zgodna z możliwościami API i zawiera spostrzeżenia z sesji planowania.

Najpierw dokładnie przejrzyj następujące dokumenty:

Dokument wymagań produktu (PRD):
<prd>
@prd.md 
</prd>

Plan API:
<api_plan>
@api-plan.md 
</api_plan>

Session Notes:
<session_notes>

<conversation_summary>
<decisions>
1. Widok główny po zalogowaniu to pulpit (/dashboard) z listą zestawów i przyciskami do tworzenia nowych.
2. Do przechowywania tymczasowo wygenerowanych fiszek (przed zapisem) będzie używany dedykowany, lokalny stan w komponencie.
3. Zostanie stworzony jeden reużywalny komponent SetEditor działający w dwóch trybach: review (dla nowo wygenerowanych fiszek) i edit (dla istniejących zestawów).
4. Błędy serwera (5xx) będą obsługiwane przez globalne powiadomienia ("toasts"), a błędy walidacji (4xx) będą wyświetlane bezpośrednio przy polach formularza.
5. Trasy wymagające logowania będą chronione przez "obudowę" (layout), która przekieruje niezalogowanych użytkowników na stronę logowania.
6. Logika algorytmu powtórek (spaced repetition) zostanie pominięta w MVP UI i będzie zaimplementowana w backendzie w przyszłości.
7. Długotrwałe akcje, jak generowanie fiszek, będą sygnalizowane przez zablokowanie przycisku i pokazanie wskaźnika ładowania (spinner).
8. Wymagania dotyczące dostępności (WCAG) nie będą uwzględniane w ramach MVP.
9. Paginacja na liście zestawów będzie klasyczna, z przyciskami "Następna"/"Poprzednia".
10. Proces generowania i recenzji fiszek będzie odbywał się dynamicznie w ramach jednego widoku (/generate).
11. Do zarządzania globalnym stanem sesji użytkownika zostanie użyta biblioteka Zustand.
12. Ręczne tworzenie zestawu rozpoczyna się od modala z prośbą o nazwę, a następnie przekierowuje do widoku edycji.
13. Panel użytkownika (/profile) w MVP będzie zawierał tylko nazwę użytkownika i przycisk wylogowania.
14. Walidacja danych w formularzach (np. długość tekstu) będzie implementowana po stronie klienta.
</decisions>
<matched_recommendations>
1. Pulpit z listą istniejących zestawów powinien być widokiem głównym po zalogowaniu, zawierającym akcje "Generuj zestaw z tekstu" i "Stwórz zestaw ręcznie".
2. Należy zaimplementować dedykowany, lokalny stan do przechowywania propozycji fiszek, który będzie modyfikowany w widoku recenzji przed wysłaniem do API.
3. Należy stworzyć jeden, reużywalny komponent SetEditor, który przyjmuje dane zestawu oraz definiuje tryb pracy ('review' vs 'edit').
4. Zaleca się wykorzystanie globalnego systemu powiadomień ("toasts") dla błędów serwera (5xx) oraz wyświetlanie błędów walidacji (4xx) bezpośrednio przy polach formularza.
5. Należy zaimplementować "obudowę" (layout) dla chronionych widoków, która weryfikuje status autentykacji i przekierowuje w razie potrzeby.
6. Zaleca się implementację "Optimistic UI" dla operacji takich jak dodawanie, edycja czy usuwanie pojedynczej fiszki.
7. Przycisk "Generuj fiszki" powinien zostać zablokowany i pokazywać wskaźnik ładowania po kliknięciu.
8. Każdy element na liście zestawów powinien wyświetlać nazwę, liczbę fiszek, datę utworzenia oraz przyciski akcji: "Ucz się", "Edytuj", "Usuń".
9. Kliknięcie "Stwórz zestaw ręcznie" powinno otworzyć modal do wpisania nazwy, a następnie przekierować do pustego widoku SetEditor.
10. W widoku edycji, nad listą fiszek, powinien znajdować się stały formularz do ręcznego dodawania nowych kart.
11. Należy zaimplementować walidację po stronie klienta, która odzwierciedla reguły zdefiniowane w API.
</matched_recommendations>
<ui_architecture_planning_summary>
Na podstawie analizy dokumentacji i przeprowadzonej dyskusji, architektura interfejsu użytkownika dla MVP 10xCards została zaplanowana w następujący sposób:
a. Główne wymagania dotyczące architektury UI
Architektura opierać się będzie na frameworku Astro z wykorzystaniem komponentów React do dynamicznych części interfejsu. Projekt UI będzie realizowany z użyciem Tailwind CSS i gotowych komponentów Shadcn/ui. Kluczowe jest zapewnienie płynnego i intuicyjnego doświadczenia użytkownika podczas tworzenia i zarządzania zestawami fiszek, z wyraźnym feedbackiem na akcje użytkownika i stany ładowania.
b. Kluczowe widoki, ekrany i przepływy użytkownika
Zdefiniowano następującą strukturę widoków (stron Astro):
* /auth: Ekran logowania i rejestracji.
* /dashboard: Główny pulpit po zalogowaniu, wyświetlający paginowaną listę zestawów fiszek użytkownika oraz przyciski do inicjowania tworzenia nowych zestawów.
* /generate: Widok do generowania fiszek z tekstu. Zawiera pole tekstowe z licznikiem znaków. Po wygenerowaniu, widok dynamicznie zmienia się, aby wyświetlić komponent SetEditor w trybie recenzji (review).
* /sets/[id]: Widok do edycji istniejącego zestawu, wykorzystujący komponent SetEditor w trybie edycji (edit).
* /profile: Prosty panel użytkownika z opcją wylogowania.
* /study-session/[id]: Ekran sesji nauki (pominięty w obecnym planowaniu, do zaimplementowania w przyszłości).
Przepływy użytkownika:
* Generowanie AI: Użytkownik wchodzi na /generate, wkleja tekst, klika "Generuj", czeka (widzi spinner), a następnie na tej samej stronie recenzuje, edytuje, nazywa i zapisuje nowy zestaw. Po zapisie jest przekierowywany na /dashboard.
* Tworzenie ręczne: Użytkownik na /dashboard klika "Stwórz ręcznie", w modalu podaje nazwę, jest przekierowywany na /sets/[id], gdzie ręcznie dodaje fiszki jedna po drugiej.
c. Strategia integracji z API i zarządzania stanem
* Zarządzanie stanem: Do przechowywania globalnych danych o sesji użytkownika (status logowania, dane profilowe) zostanie użyta lekka biblioteka Zustand. Stan tymczasowy, np. lista wygenerowanych przez AI fiszek przed zapisaniem, będzie zarządzany lokalnie w odpowiednich komponentach React (useState).
* Integracja z API: Interakcje z API będą realizowane poprzez bezpośrednie wywołania fetch. Po pomyślnym stworzeniu nowego zestawu, użytkownik zostanie przekierowany na pulpit, co spowoduje odświeżenie listy.
* Walidacja i błędy: Walidacja danych formularzy (np. długość pól) będzie realizowana po stronie klienta, aby dać użytkownikowi natychmiastowy feedback. Błędy walidacyjne z API (np. zduplikowana nazwa) będą wyświetlane przy polach formularza, a ogólne błędy serwera za pomocą globalnych powiadomień "toast".
d. Kwestie dotyczące responsywności, dostępności i bezpieczeństwa
* Responsywność: Zastosowane zostanie podejście "mobile-first", zapewniające użyteczność na różnych urządzeniach.
* Dostępność: Została świadomie wyłączona z zakresu MVP.
* Bezpieczeństwo: Widoki wymagające autentykacji (/dashboard, /generate, /sets/[id], /profile) będą chronione przez layout w Astro, który sprawdzi status sesji użytkownika i w razie potrzeby przekieruje go na stronę logowania (/auth). Interceptor dla zapytań API będzie obsługiwał błędy 401 Unauthorized, również przekierowując użytkownika.
</ui_architecture_planning_summary>
<unresolved_issues>
* Szczegółowy projekt UI ekranu autentykacji: Zdecydowano o formie zakładek "Logowanie"/"Rejestracja", ale szczegółowy layout i obsługa błędów wymagają doprecyzowania.
* Strategia odświeżania danych: Uproszczono strategię do przekierowania i pełnego odświeżenia. Rozważenie bardziej zaawansowanych bibliotek jak SWR czy React Query zostało odłożone na później.
* Implementacja ekranu sesji nauki: Cała funkcjonalność i projekt interfejsu do nauki (/study-session/[id]) zostały pominięte i wymagają osobnego zaplanowania.
</unresolved_issues>
</conversation_summary>

</session_notes>

Twoim zadaniem jest stworzenie szczegółowej architektury interfejsu użytkownika, która obejmuje niezbędne widoki, mapowanie podróży użytkownika, strukturę nawigacji i kluczowe elementy dla każdego widoku. Projekt powinien uwzględniać doświadczenie użytkownika, dostępność i bezpieczeństwo.

Wykonaj następujące kroki, aby ukończyć zadanie:

1. Dokładnie przeanalizuj PRD, plan API i notatki z sesji.
2. Wyodrębnij i wypisz kluczowe wymagania z PRD.
3. Zidentyfikuj i wymień główne punkty końcowe API i ich cele.
4. Utworzenie listy wszystkich niezbędnych widoków na podstawie PRD, planu API i notatek z sesji.
5. Określenie głównego celu i kluczowych informacji dla każdego widoku.
6. Zaplanuj podróż użytkownika między widokami, w tym podział krok po kroku dla głównego przypadku użycia.
7. Zaprojektuj strukturę nawigacji.
8. Zaproponuj kluczowe elementy interfejsu użytkownika dla każdego widoku, biorąc pod uwagę UX, dostępność i bezpieczeństwo.
9. Rozważ potencjalne przypadki brzegowe lub stany błędów.
10. Upewnij się, że architektura interfejsu użytkownika jest zgodna z planem API.
11. Przejrzenie i zmapowanie wszystkich historyjek użytkownika z PRD do architektury interfejsu użytkownika.
12. Wyraźne mapowanie wymagań na elementy interfejsu użytkownika.
13. Rozważ potencjalne punkty bólu użytkownika i sposób, w jaki interfejs użytkownika je rozwiązuje.

Dla każdego głównego kroku pracuj wewnątrz tagów <ui_architecture_planning> w bloku myślenia, aby rozbić proces myślowy przed przejściem do następnego kroku. Ta sekcja może być dość długa. To w porządku, że ta sekcja może być dość długa.

Przedstaw ostateczną architekturę interfejsu użytkownika w następującym formacie Markdown:

```markdown
# Architektura UI dla [Nazwa produktu]

## 1. Przegląd struktury UI

[Przedstaw ogólny przegląd struktury UI]

## 2. Lista widoków

[Dla każdego widoku podaj:
- Nazwa widoku
- Ścieżka widoku
- Główny cel
- Kluczowe informacje do wyświetlenia
- Kluczowe komponenty widoku
- UX, dostępność i względy bezpieczeństwa]

## 3. Mapa podróży użytkownika

[Opisz przepływ między widokami i kluczowymi interakcjami użytkownika]

## 4. Układ i struktura nawigacji

[Wyjaśnij, w jaki sposób użytkownicy będą poruszać się między widokami]

## 5. Kluczowe komponenty

[Wymień i krótko opisz kluczowe komponenty, które będą używane w wielu widokach].
```

Skup się wyłącznie na architekturze interfejsu użytkownika, podróży użytkownika, nawigacji i kluczowych elementach dla każdego widoku. Nie uwzględniaj szczegółów implementacji, konkretnego projektu wizualnego ani przykładów kodu, chyba że są one kluczowe dla zrozumienia architektury.

Końcowy rezultat powinien składać się wyłącznie z architektury UI w formacie Markdown w języku polskim, którą zapiszesz w pliku .ai/ui-plan.md. Nie powielaj ani nie powtarzaj żadnej pracy wykonanej w bloku myślenia.